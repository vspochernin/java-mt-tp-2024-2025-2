# java-mt-tp-2024-2025-2
Курсовая работа «Thread Pool» по дисциплине "Многопоточное и асинхронное программирование на Java". 2-й семестр 1-го 
курса МИФИ ИИКС РПО (2024-2025 уч. г).

## Описание проекта

Данный проект представляет собой реализацию собственного пула потоков (Thread Pool) на Java. Проект разработан в рамках курсовой работы по дисциплине "Многопоточное и асинхронное программирование на Java". Подробное описание требований к проекту находится в файле [task.md](task.md).

## Что было сделано

1. Реализован интерфейс `CustomExecutor`, расширяющий стандартный `Executor`
2. Создан класс `CustomThreadPool` с поддержкой:
   - Настройки основных параметров (corePoolSize, maxPoolSize, keepAliveTime и др.).
   - Множественных очередей задач.
   - Механизма балансировки нагрузки.
   - Политик обработки отказов.
3. Реализован `CustomThreadFactory` для создания потоков с уникальными именами.
4. Создан класс `Worker` для обработки задач из очередей.
5. Реализовано подробное логирование всех ключевых событий.
6. Написана демонстрационная программа, показывающая:
   - Базовую работу пула.
   - Обработку разных типов задач.
   - Работу различных политик отказа.
   - Корректное завершение работы.

## Принцип действия

### Распределение задач и балансировка

В пуле реализован механизм Round Robin для распределения задач между очередями. Каждый воркер имеет свою собственную очередь задач. При поступлении новой задачи:

1. Сначала проверяется возможность создания нового воркера (если текущее количество меньше maxPoolSize).
2. Если создание нового воркера невозможно, задача добавляется в следующую очередь по принципу Round Robin.
3. Если очередь переполнена, применяется выбранная политика отказа.

### Политики отказа

Реализованы три политики обработки отказов:
1. `ABORT` - просто отклоняет задачу.
2. `CALLER_RUNS` - выполняет задачу в текущем потоке.
3. `RETRY_AFTER_DELAY` - пытается выполнить задачу позже.

## Анализ производительности

### Сравнение со стандартным ThreadPoolExecutor

1. Преимущества нашего решения:
   - Более гибкое управление очередями (отдельная очередь на каждый поток).
   - Возможность настройки минимального количества резервных потоков.
   - Более детальное логирование.
   - Кастомизируемые политики отказа (в будущем легко добавить свою политику при необходимости).

2. Недостатки:
   - Меньшая оптимизация для высоконагруженных систем.
   - Отсутствие некоторых продвинутых функций (например, scheduled tasks).

### Сравнение с Tomcat Thread Pool

Tomcat использует более сложную реализацию пула потоков с:
- Динамическим масштабированием.
- Мониторингом производительности.
- Интеграцией с системой управления памятью.

Наше решение проще, но более гибкое в настройке и лучше подходит для кастомизации под конкретные нужды.

## Мини-исследование параметров

Проведено тестирование с разными параметрами:

1. Оптимальные параметры для CPU-bound задач:
   - corePoolSize = количество ядер CPU.
   - maxPoolSize = corePoolSize * 2.
   - queueSize = 100-200.
   - keepAliveTime = 60 секунд.

2. Оптимальные параметры для IO-bound задач:
   - corePoolSize = количество ядер CPU * 2.
   - maxPoolSize = corePoolSize * 4.
   - queueSize = 500-1000.
   - keepAliveTime = 30 секунд.

3. Общие рекомендации:
   - minSpareThreads = corePoolSize / 2.
   - queueSize не должен быть слишком большим во избежание проблем с памятью.
   - keepAliveTime зависит от характера задач (длинные задачи требуют большего времени).
