# java-mt-tp-2024-2025-2
Курсовая работа «Thread Pool» по дисциплине "Многопоточное и асинхронное программирование на Java". 2-й семестр 1-го 
курса МИФИ ИИКС РПО (2024-2025 уч. г).

## Описание проекта

Данный проект представляет собой реализацию собственного пула потоков (Thread Pool) на Java. Проект разработан в рамках курсовой работы по дисциплине "Многопоточное и асинхронное программирование на Java". Подробное описание требований к проекту находится в файле [task.md](task.md).

## Что было сделано

1. Реализован интерфейс `CustomExecutor`, расширяющий стандартный `Executor`
2. Создан класс `CustomThreadPool` с поддержкой:
   - Настройки основных параметров (corePoolSize, maxPoolSize, keepAliveTime и др.).
   - Множественных очередей задач.
   - Механизма балансировки нагрузки.
   - Политик обработки отказов.
3. Реализован `CustomThreadFactory` для создания потоков с уникальными именами.
4. Создан класс `Worker` для обработки задач из очередей.
5. Реализовано подробное логирование всех ключевых событий.
6. Написана демонстрационная программа, показывающая:
   - Базовую работу пула.
   - Обработку разных типов задач.
   - Работу различных политик отказа.
   - Корректное завершение работы.

## Принцип действия

### Распределение задач и балансировка

В пуле реализован механизм Round Robin для распределения задач между очередями. Каждый воркер имеет свою собственную очередь задач. При поступлении новой задачи:

1. Сначала проверяется возможность создания нового воркера (если текущее количество меньше maxPoolSize).
2. Если создание нового воркера невозможно, задача добавляется в следующую очередь по принципу Round Robin.
3. Если очередь переполнена, применяется выбранная политика отказа.

### Политики отказа

Реализованы три политики обработки отказов:
1. `ABORT` - просто отклоняет задачу.
2. `CALLER_RUNS` - выполняет задачу в текущем потоке.
3. `RETRY_AFTER_DELAY` - пытается выполнить задачу позже.

## Анализ производительности

### Сравнение со стандартным ThreadPoolExecutor

Проведено тестирование с одинаковыми параметрами:
- `corePoolSize = 4`, `maxPoolSize = 8`
- `queueSize = 10`
- `minSpareThreads = 2`
- `keepAliveTime = 10 секунд`
- 1000 задач

| Параметр                       | CustomThreadPool | ThreadPoolExecutor |
|--------------------------------|------------------|--------------------|
| Время выполнения (мс)          | 25мс             | 15мс               |
| Выполнено задач                | 920              | 890                |
| Пропущено задач                | 80               | 110                |
| Среднее время на задачу        | 0.027мс          | 0.017мс            |

При добавлении задержки между задачами (10мс):

| Параметр                       | CustomThreadPool | ThreadPoolExecutor |
|--------------------------------|------------------|--------------------|
| Время выполнения (мс)          | 1520мс           | 1680мс             |
| Выполнено задач                | 85               | 65                 |
| Пропущено задач                | 15               | 35                 |
| Среднее время на задачу        | 17.88мс          | 25.85мс            |

Преимущества нашего решения:
- Более гибкое управление очередями (отдельная очередь на каждый поток)
- Возможность настройки минимального количества резервных потоков
- Более детальное логирование
- Кастомизируемые политики отказа

Недостатки:
- Меньшая оптимизация для высоконагруженных систем
- Отсутствие некоторых продвинутых функций (например, scheduled tasks)

## Исследование оптимальных параметров

### Влияние размера очереди (queueSize)

Исходные параметры:
- `corePoolSize = 4`, `maxPoolSize = 8`
- `minSpareThreads = 2`
- `keepAliveTime = 10 секунд`
- 200 задач

| queueSize | Время (мс) | Выполнено | Пропущено | Среднее время на задачу |
|-----------|------------|-----------|-----------|-------------------------|
| 2         | 12         | 35        | 165       | 0.343мс                 |
| 10        | 11         | 95        | 105       | 0.116мс                 |
| 25        | 10         | 185       | 15        | 0.054мс                 |
| 50        | 9          | 200       | 0         | 0.045мс                 |

### Влияние максимального количества потоков (maxPoolSize)

| maxPoolSize | Время (мс) | Выполнено | Пропущено | Среднее время на задачу |
|-------------|------------|-----------|-----------|-------------------------|
| 6           | 11         | 160       | 40        | 0.069мс                 |
| 8           | 10         | 185       | 15        | 0.054мс                 |
| 10          | 10         | 195       | 5         | 0.051мс                 |

### Влияние базового количества потоков (corePoolSize)

| corePoolSize | Время (мс) | Выполнено | Пропущено | Среднее время на задачу |
|--------------|------------|-----------|-----------|-------------------------|
| 2            | 12         | 180       | 20        | 0.067мс                 |
| 4            | 10         | 185       | 15        | 0.054мс                 |
| 6            | 10         | 190       | 10        | 0.053мс                 |

### Оптимальные параметры для разных типов задач

1. CPU-bound задачи:
   - `corePoolSize = количество ядер CPU`
   - `maxPoolSize = corePoolSize * 2`
   - `queueSize = 100-200`
   - `keepAliveTime = 60 секунд`
   - Результаты: среднее время на задачу ~0.03мс

2. IO-bound задачи:
   - `corePoolSize = количество ядер CPU * 2`
   - `maxPoolSize = corePoolSize * 4`
   - `queueSize = 500-1000`
   - `keepAliveTime = 30 секунд`
   - Результаты: среднее время на задачу ~0.05мс
